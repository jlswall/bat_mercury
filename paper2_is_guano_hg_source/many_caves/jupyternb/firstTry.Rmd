---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.0'
      jupytext_version: 0.8.6
  kernelspec:
    display_name: R
    language: R
    name: ir
---

## Setup


Read in some packages we'll need.

```{r}
library("ggplot2")
library("readxl")
library("dplyr")
library("readr")
```

Read in the dataset.

```{r}
allT <- read_xlsx(path="../Hg_Data_Cave_Mercury_2018-10-16.xlsx")
```

Remove columns we don't need; rename the others.

```{r}
allT <- allT[,c(1:2, 4, 6)]
colnames(allT) <- c("origCaveName", "region", "sampleType", "mercury")
```

### Dealing with core samples

Some of these data come from core samples, with measurements taken every inch throughout the core.  We add an extra column that represents the core to which the measurements belong (contains NA for the rows which aren't from core samples).  I have to do this by hand, because some of the notes that contain "core" are composite measurements, or there could be more than one core per cave.

```{r}
## Initialize coreID and distFromSurface variables:
allT$coreID <- "not core"
allT$distFromSurface <- 0

## For Climax Cave, we have a 10-in core:
allT$coreID[34:43] <- "core 1"
allT$distFromSurface[34:43] <- 0:9

## For Cottondale, we have a 6-in core:
allT$coreID[53:58] <- "core 1"
allT$distFromSurface[53:58] <- 0:5

## For Florida Caverns Old Indian Cave, we have two 8-in cores:
allT$coreID[61:68] <- "core 1"
allT$distFromSurface[61:68] <- 0:7
allT$coreID[69:76] <- "core 2"
allT$distFromSurface[69:76] <- 0:7

## For Judge's Cave, we have an 11-inch core and a 8-inch core:
allT$coreID[125:135] <- "core 1"
allT$distFromSurface[125:135] <- 0:10
allT$coreID[136:143] <- "core 2"
allT$distFromSurface[136:143] <- 0:7
```

### Shorter cave names

Merge in shortened names for use when plotting.  I've already entered these names by hand in a CSV file.

```{r}
caveNamesT <- read_csv("../orig_and_short_cave_names.csv")
## Merge in the data frame giving the correspondence between the
## original names and shortened versions of those names.
allT <- allT %>% inner_join(caveNamesT)
rm(caveNamesT)
```

### Exploratory plots


This plot is in the original units.

```{r}
ggplot(allT, aes(x=cave, y=sqrt(mercury))) +
  geom_jitter(aes(color=sampleType, shape=coreID), width=0.2) +
  facet_wrap(~region, scales="free_x") +
  theme(axis.text.x = element_text(angle=90)) +
  labs(y="Mercury")
```

Replace the observations from guano cores with just one observation which is the average for that core.

```{r}
wCoreAvgsT <- bind_rows(
    allT %>% filter(coreID!="not core") %>% group_by(region, cave, coreID, sampleType) %>% summarize(mercury=mean(mercury)),
    allT %>% select(region, cave, coreID, sampleType, mercury) %>% filter(coreID=="not core")
) %>% arrange(region, cave, sampleType)

```

```{r}
ggplot(wCoreAvgsT, aes(x=cave, y=mercury)) +
  geom_jitter(aes(color=sampleType), width=0.2) +
  facet_wrap(~region, scales="free_x") +
  theme(axis.text.x = element_text(angle=90)) +
  labs(y="Mercury")
```

```{r}
ggplot(wCoreAvgsT, aes(x=cave, y=sqrt(mercury))) +
  geom_jitter(aes(color=sampleType), width=0.2) +
  facet_wrap(~region, scales="free_x") +
  theme(axis.text.x = element_text(angle=90)) +
  labs(y="sqrt(Mercury)")

```

```{r}
ggplot(wCoreAvgsT, aes(x=sampleType, y=mercury, fill=sampleType)) +
    geom_boxplot() +
    facet_wrap(~region)
```

```{r}
ggplot(wCoreAvgsT, aes(x=sampleType, y=sqrt(mercury), fill=sampleType)) +
    geom_boxplot() +
    facet_wrap(~region)
```

### Prepare to do MCMC using Stan.

Re-order the data frame so that it's sorted by region, then by cave, and then by sample type (sediment before guano).

```{r}
wCoreAvgsT <- wCoreAvgsT %>% arrange(region, cave, desc(sampleType))
```

We'll have a fixed effect for each region.  We build the design matrix.

```{r}
numReg <- length(unique(wCoreAvgsT$region))
Xmu <- matrix(NA, nrow=nrow(wCoreAvgsT), ncol=numReg)
for (i in 1:ncol(Xmu))
  Xmu[,i] <- ifelse(wCoreAvgsT$region==i, 1, 0)
```

We'll have a fixed effect for guano (vs. sediment) for each region.

```{r}
Xbeta <- matrix(NA, nrow=nrow(wCoreAvgsT), ncol=numReg)
for (i in 1:ncol(Xmu))
  Xbeta[,i] <- ifelse((wCoreAvgsT$region==i) & (wCoreAvgsT$sampleType=="G"), 1, 0)
```

Call Stan to fit a basic model with fixed effects for region and sample type.

```{r}
library("rstan")
basicLst <- list(numObs = nrow(wCoreAvgsT),
                 numReg = numReg,
                 y = wCoreAvgsT$mercury,
                 Xmu = Xmu,
                 Xbeta = Xbeta,
                 nu=3)
## Need to use pars statement so that yhat vector won't be stored.
fit <- stan(file='basic_model.stan', data=basicLst, chains=1, warmup=1000, iter=2000)
## fit <- stan(model_code=modelStr, data=basicLst, chains=1, warmup=10000, iter=20000, thin=10)
```

```{r}
plot(fit)
```

```{r}
yRep <- as.matrix(fit, pars="yRep")
library("bayesplot")
ppc_dens_overlay(wCoreAvgsT$mercury, yRep[1:1000, ], alpha=1, xlim=c(-2.5, 2.5))
```

Set up matrix for cave effects for guano.

```{r}
caveNms <- unique(wCoreAvgsT$cave)
numCav <- length(caveNms)
Xtheta <- matrix(NA, nrow=nrow(wCoreAvgsT), ncol=numCav)
for (i in 1:numCav)
  Xtheta[,i] <- ifelse((wCoreAvgsT$cave==caveNms[i]) & (wCoreAvgsT$sampleType=="G"), 1, 0)
```

```{r}
caveEffLst <- list(numObs=nrow(wCoreAvgsT),
                  numReg=numReg,
                  numCav=numCav,
                  y=wCoreAvgsT$mercury,
                  Xmu=Xmu,
                  Xbeta=Xbeta,
                  Xtheta=Xtheta,
                  nu=3)
```

```{r}
## fit <- stan(file='cave_effects.stan', data=caveEffLst, chains=1, warmup=1000, iter=2000)
```

```{r}
## plot(fit)
```

```{r}

```
