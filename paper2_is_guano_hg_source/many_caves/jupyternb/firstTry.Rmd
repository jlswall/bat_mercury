---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.0'
      jupytext_version: 0.8.6
  kernelspec:
    display_name: R
    language: R
    name: ir
---

## Setup


Read in some packages we'll need.

```{r}
library("ggplot2")
library("readxl")
library("dplyr")
library("readr")
## Limit the height of plots appearing in the notebook.
options(repr.plot.height=4.5)
```

Read in the dataset.

```{r}
allT <- read_xlsx(path="../Hg_Data_Cave_Mercury_2018-10-16.xlsx")
```

Remove columns we don't need; rename the others.

```{r}
allT <- allT[,c(1:2, 4, 6)]
colnames(allT) <- c("origCaveName", "region", "sampleType", "mercury")
```

### Dealing with core samples

Some of these data come from core samples, with measurements taken every inch throughout the core.  We add an extra column that represents the core to which the measurements belong (contains NA for the rows which aren't from core samples).  I have to do this by hand, because some of the notes that contain "core" are composite measurements, or there could be more than one core per cave.

```{r}
## Initialize coreID and distFromSurface variables:
allT$coreID <- "not core"
allT$distFromSurface <- 0

## For Climax Cave, we have a 10-in core:
allT$coreID[34:43] <- "core 1"
allT$distFromSurface[34:43] <- 0:9

## For Cottondale, we have a 6-in core:
allT$coreID[53:58] <- "core 1"
allT$distFromSurface[53:58] <- 0:5

## For Florida Caverns Old Indian Cave, we have two 8-in cores:
allT$coreID[61:68] <- "core 1"
allT$distFromSurface[61:68] <- 0:7
allT$coreID[69:76] <- "core 2"
allT$distFromSurface[69:76] <- 0:7

## For Judge's Cave, we have an 11-inch core and a 8-inch core:
allT$coreID[125:135] <- "core 1"
allT$distFromSurface[125:135] <- 0:10
allT$coreID[136:143] <- "core 2"
allT$distFromSurface[136:143] <- 0:7
```

### Shorter cave names

Merge in shortened names for use when plotting.  I've already entered these names by hand in a CSV file.

```{r}
caveNamesT <- read_csv("../orig_and_short_cave_names.csv")
## Merge in the data frame giving the correspondence between the
## original names and shortened versions of those names.
allT <- allT %>% inner_join(caveNamesT)
rm(caveNamesT)
```

### Checking numbers of sediment and guano measurements by cave.

First, I count how many sediment observations there are for each cave, and I save a list of all caves which have 3 or more sediment observations.

```{r}
hasSedimentT <- allT %>%
    filter(sampleType=="S") %>%
    group_by(cave) %>%
    summarize(numobs=n()) %>%
    filter(numobs >= 3)
```

Next, count how many guano measurements there are for each cave and save the table.  This counts each core measurement separately.

```{r}
hasGuanoT <- allT %>%
    filter(sampleType=="G") %>%
    group_by(cave) %>%
    summarize(numobs=n()) %>%
    filter(numobs >= 3)
```

Make a list of the caves that appear on both lists; that is, they have enough measurements of both types.

```{r}
cavesWBoth <- hasSedimentT %>% select(cave) %>% inner_join(hasGuanoT %>% select(cave))
```

Make a subset of the data with just these caves and *without* averaging the core measurements.

```{r}
enoughBothT <- allT %>% inner_join(cavesWBoth)
```

Looking at this subset, how many measurements were taken as a part of a core, and which caves were they in?

```{r}
enoughBothT %>% group_by(cave, region, sampleType, coreID) %>% summarize(numobs=n())
```

So, Climax and Cottondale each had one core set, with 10 observations from a single core in Climax Cave and 6 from a core in Cottondale Cave.  Let's see if these appear to be autocorrelated.

First, we look at a plot of the guano measurements for both caves, with the core measurements separated from the others.

```{r}
ggplot(subset(enoughBothT, cave %in% c("Climax", "Cottondale") & sampleType=="G"),
       aes(x=coreID, y=mercury)) +
    geom_jitter(aes(color=coreID)) +
    facet_wrap(~cave)
```

The core measurements from the Climax Cave appear to be clustered together.  Do a test of the variance between the core and non-core measurments.

```{r}
with(subset(enoughBothT, cave=="Climax" & sampleType=="G"),
     fligner.test(mercury ~ as.factor(coreID))
    )
with(subset(enoughBothT, cave=="Cottondale" & sampleType=="G"),
     fligner.test(mercury ~ as.factor(coreID))
    )
```

The auto-correlation structure is not easy to model.  Therefore, we can account for it by using the average of each core, or maybe by using some sort of block effect in a mixed model.

```{r}
with(subset(enoughBothT, coreID=="core 1" & cave=="Climax"), acf(mercury))
```

We build a tibble that uses the average of each core, rather than the individual core measurements.

```{r}
wCoreAvgsT <- bind_rows(
    enoughBothT %>%
        filter(coreID!="not core") %>%
        group_by(region, cave, coreID, sampleType) %>%
        summarize(mercury=mean(mercury)),
    enoughBothT %>%
        select(region, cave, coreID, sampleType, mercury) %>%
        filter(coreID=="not core")
    ) %>%
    arrange(region, cave, sampleType)
```

### Exploratory plots

We consider using mercury in original units, using the square root of mercury, or using the log base 10 of mercury.

```{r}
ggplot(wCoreAvgsT, aes(x=cave, y=mercury)) +
  geom_jitter(aes(color=sampleType), width=0.2) +
  facet_wrap(~region, scales="free_x") +
  theme(axis.text.x = element_text(angle=90)) +
  labs(y="Mercury")
```

```{r}
ggplot(wCoreAvgsT, aes(x=cave, y=log10(mercury))) +
  geom_jitter(aes(color=sampleType), width=0.2) +
  facet_wrap(~region, scales="free_x") +
  theme(axis.text.x = element_text(angle=90)) +
  labs(y="log10(Mercury)")
```

```{r}
ggplot(wCoreAvgsT, aes(x=cave, y=sqrt(mercury))) +
  geom_jitter(aes(color=sampleType), width=0.2) +
  facet_wrap(~region, scales="free_x") +
  theme(axis.text.x = element_text(angle=90)) +
  labs(y="sqrt(Mercury)")
```

### Try using linear mixed effects models.

First, we look at a simple model, using sampleType as the fixed effect and including cave as the random effect.  Unfortunately, since we only have one cave in region 2, we'll have to remove region 2 (which means Climax Cave) from consideration.

```{r}
library("lme4")
woutReg2T <- subset(wCoreAvgsT, region!=2)
woutReg2T$region <- as.factor(woutReg2T$region)
```

Re-draw the dotplots without region 2.

```{r}
ggplot(woutReg2T, aes(x=cave, y=mercury)) +
  geom_jitter(aes(color=sampleType), width=0.2) +
  facet_wrap(~region, scales="free_x") +
  theme(axis.text.x = element_text(angle=90)) +
  labs(y="Mercury")
```

```{r}
ggplot(woutReg2T, aes(x=cave, y=sqrt(mercury))) +
  geom_jitter(aes(color=sampleType), width=0.2) +
  facet_wrap(~region, scales="free_x") +
  theme(axis.text.x = element_text(angle=90)) +
  labs(y="sqrt(Mercury)")
```

```{r}
basicLME <- lmer(sqrt(mercury) ~ sampleType + (1 + sampleType|cave), data=woutReg2T)
summary(basicLME)
```

This shows a significant effect of sample type (guano vs. sediment).  Now, we try adding region to the model.

```{r}
regionLME <- lmer(sqrt(mercury) ~ region + sampleType + (1 + sampleType|cave), data=woutReg2T)
summary(regionLME)
```

Region is not highly significant, but the distinction between sample types still is significant.  Compare the two models using anova().

```{r}
anova(basicLME, regionLME)
```

This indicates that the addition of region does have a substantial impact on the model (p<0.05).  What happens if we add an interaction effect?

```{r}
regslopeLME <- lmer(sqrt(mercury) ~ as.factor(region)*sampleType + (1 + sampleType|cave), data=woutReg2T)
summary(regslopeLME)
```

```{r}
anova(basicLME, regionLME, regslopeLME)
```

```{r}
randomslopeLME <- lmer(sqrt(mercury) ~ as.factor(region) + sampleType + (1+sampleType|cave),
                       data=woutReg2T)
summary(randomslopeLME)
```

```{r}
anova(basicLME, regionLME, regslopeLME, randomslopeLME)
```

### Prepare to do MCMC using Stan.

Re-order the data frame so that it's sorted by region, then by cave, and then by sample type (sediment before guano).

```{r}
## wCoreAvgsT <- wCoreAvgsT %>% arrange(region, cave, desc(sampleType))
```

We'll have a fixed effect for each region.  We build the design matrix.

```{r}
## numReg <- length(unique(wCoreAvgsT$region))
## Xmu <- matrix(NA, nrow=nrow(wCoreAvgsT), ncol=numReg)
## for (i in 1:ncol(Xmu))
##  Xmu[,i] <- ifelse(wCoreAvgsT$region==i, 1, 0)
```

We'll have a fixed effect for guano (vs. sediment) for each region.

```{r}
## Xbeta <- matrix(NA, nrow=nrow(wCoreAvgsT), ncol=numReg)
## for (i in 1:ncol(Xmu))
##  Xbeta[,i] <- ifelse((wCoreAvgsT$region==i) & (wCoreAvgsT$sampleType=="G"), 1, 0)
```

Call Stan to fit a basic model with fixed effects for region and sample type.

```{r}
## library("rstan")
## basicLst <- list(numObs = nrow(wCoreAvgsT),
##                 numReg = numReg,
##                 y = wCoreAvgsT$mercury,
##                 Xmu = Xmu,
##                 Xbeta = Xbeta,
##                 nu=3)
## Need to use pars statement so that yhat vector won't be stored.
## fit <- stan(file='basic_model.stan', data=basicLst, chains=1, warmup=1000, iter=2000)
## fit <- stan(model_code=modelStr, data=basicLst, chains=1, warmup=10000, iter=20000, thin=10)
```

```{r}
## plot(fit)
```

```{r}
## yRep <- as.matrix(fit, pars="yRep")
## library("bayesplot")
## ppc_dens_overlay(wCoreAvgsT$mercury, yRep[1:1000, ], alpha=1, xlim=c(-2.5, 2.5))
```

Set up matrix for cave effects for guano.

```{r}
## caveNms <- unique(wCoreAvgsT$cave)
## numCav <- length(caveNms)
## Xtheta <- matrix(NA, nrow=nrow(wCoreAvgsT), ncol=numCav)
##for (i in 1:numCav)
##  Xtheta[,i] <- ifelse((wCoreAvgsT$cave==caveNms[i]) & (wCoreAvgsT$sampleType=="G"), 1, 0)
```

```{r}
## caveEffLst <- list(numObs=nrow(wCoreAvgsT),
##                  numReg=numReg,
##                  numCav=numCav,
##                  y=wCoreAvgsT$mercury,
##                  Xmu=Xmu,
##                  Xbeta=Xbeta,
##                  Xtheta=Xtheta,
##                  nu=3)
```

```{r}
## fit <- stan(file='cave_effects.stan', data=caveEffLst, chains=1, warmup=1000, iter=2000)
```

```{r}
## plot(fit)
```

```{r}

```
